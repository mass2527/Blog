---
title: "React, Svelte 무엇이 다를까?"
category: React, Svelte
summary: React와 Svelte는 어떠한 철학을 가지고 만들어졌는지, 어떤 점이 다른지 비교해 봅니다.
published: true
publishedAt: "2024-04-15"
---

## 핵심 철학 비교

### React

[Minimal API를 지향하며 개발자가 가능한 많은 명시적(explicit) 코드를 작성하도록 만든다.](https://www.youtube.com/watch?v=4anAwXYqLG8)

**장점과 그에 따른 비용들**

| 장점 | 비용 |
| --- | --- |
| 명시적으로 드러나는 코드가 많기 때문에 비교적 이해하기 쉽다.
(숨겨지는 코드가 적기 때문에) | 비교적 많은 코드를 작성한다.
⇒ 비교적 많은 시간이 소모된다.
⇒ 버그가 있는 코드를 작성할 확률이 높아진다.
(일반적으로 버그 수는 프로젝트 개발에 드는 시간(코드)의 제곱에 비례하는 것으로 알려져 있다.) |
| 최소한의 API를 제공하기 때문에 기억해야 할 것들이 비교적 적다. | API가 최소화된다는 것은 그만큼 라이브러리가 해주는 것이 적다는 것을 의미하며 "마법"이라고 불릴 만한 것들이 없다고도 볼 수 있다. |

React는 다음과 같은 생각을 가지고 있다.

- 반복적인 코드 > 잘못된 추상화
- 명시적(explicit) 코드를 묵시적(implicit) 코드로 변경하는 것은 쉽지만 그 반대는 어렵다.

⇒ 그래서 가능한 적은 추상화를 하고 나머지는 개발자에게 맡기는 것이 더 유연하고 좋은 방법이라고 생각하는 것 같다.

### Svelte

["Write less code"](https://svelte.dev/blog/write-less-code)
Svelte는 왜 React처럼 불필요하게 많은 코드를 작성해? 귀찮거나 당연한 것들은 내가 다 해줄게!
(Maximal API를 지향하며 개발자가 가능한 적은 명시적 코드를 작성하도록 만든다.)

장점과 그에 따른 비용들

| 장점 | 비용 |
| --- | --- |
| 비교적 적은 코드를 작성한다.
⇒ 비교적 적은 시간이 소모된다.
⇒ 버그가 있는 코드를 작성할 확률이 낮아진다. | 숨기는 것이 많아진다.
- 잘 활용하기 위해서는 어떤 것이 숨겨지는지 기억하고 있어야 함(e.g. store 앞에 $를 붙이면 store에 저장된 value에 접근할 수 있으며 subscribe, unsubscribe가 자동으로 된다.) |
| 많은 것들을 svelte가 처리해 주기 때문에 "마법"처럼 되는 것들이 많다. | 어떻게 동작하는지 직관적으로 이해하기가 어렵다. |

svelte는 개발자가 많은 코드를 작성하면 시간도 오래 걸리고 더 많은 버그를 생성할 것이라고 생각한다. 따라서 React와는 상반되게 "Write less code"를 지향하는 것이 그에 따른 비용보다 더 큰 가치를 제공할 것이라고 생각하는 것 같다.

## 차이점

### Reactive

React는 처음 그리고 상태값이 변경될 때마다 컴포넌트 전체가 재호출된다.

```jsx
function NameForm() {
  const [name, setName] = useState('');

  const handleChange = (event) => {
    setName(event.target.value);
  };

  return (
    <div>
      <h1>이름 입력</h1>
      <input type="text" value={name} onChange={handleChange} />
      <p>입력된 이름: {name}</p>
    </div>
  );
}
```

위 예시에서 name이 변경될 때마다 handleChange 함수가 계속 생성되기 된다. ⇒ 불필요한 일을 수행함

반면에 Svelte는 처음에만 script 전체가 실행되고 이후에는 필요한 것만 재실행된다.

```jsx
<script>
  let name = '';

  function handleChange(event) {
    name = event.target.value;
  }
</script>

<h1>이름 입력</h1>
<input type="text" bind:value={name} on:input={handleChange} />
<p>입력된 이름: {name}</p>
```

React와 달리 `handleChange` 는 한 번만 생성된다.

⇒ 효율적이다.

### 변경을 감지하는 방법

React는 `Object.is`를 사용해서 변경을 감지한다. 상태 값을 변경할 때 기존 상태 값을 복사해야한다.

```jsx
const [todo, setTodo] = useState([])

// 상태 변경시
setTodo([...todo, newTodo])
```

Svelte 컴파일러는 `=` 을 통행 변경을 감지한다. 따라서 복사할 필요가 없다.

```jsx
let todo = [];

// 상태 변경시
todo.push(newTodo);
todo = todo;
```

### Virtual DOM 사용 유무

React 컴포넌트가 반환하는 것을 실제 DOM이 아니라 화면에 무엇을 그릴지 선언적으로 표현한 가상의 엘리먼트들에 불과하다.

```jsx
function HelloMessage(props) {
	return <div className="greeting">Hello {props.name}</div>;
}
```

이는 결과적으로 babel에 의해 컴파일 되어 순수 자바스크립트 객체로 변환되며 이를 흔히 Virtual DOM이라고 부른다. 이는 state가 변경될 때마다 항상 새롭게 생성된다.

```jsx
function HelloMessage(props) {
	return React.createElement('div', { className: 'greeting' }, 'Hello ', props.name);
}
```

React는 이렇게 생성한 Virtual DOM을 실제 DOM과 동기화시켜준다.

name이 “React”에서 “Svelte”로 변경됐을 경우 다음과 같은 일이 일어난다.

1. name이 변경되었으므로 변경된 name(”Svelte”)를 기반으로 새로운 자바스크립트 객체를 생성한다.
(`React.createElement('div', { className: 'greeting' }, 'Svelte ', props.name`) 가 생성됨)
2. 이전에 생성된 객체와 이번에 생성된 객체를 비교한다.
    1. type - 이전: div ⇒ 현재: div
    (동일 ⇒ 유지한다) 
    2. props - 이전: `{ className: 'greeting' }` ⇒ 현재: `{ className: 'greeting' }`
    (동일 ⇒ 유지한다.)
    3. 첫 번째 children - 이전: 'Hello ' ⇒ 현재: 'Hello '
    (동일 ⇒ 유지한다.)
    4. 두 번째 children - 이전: ‘React’ ⇒ 현재: ‘Svelte’
    (변경 ⇒ 변경한다.)
3. div 엘리먼트는 유지하고, children만 변경한다.
    1. divElement.textContent = 'Hello ' + ‘Svelte’;

결과적으로 변경된 부분만 실제 DOM에 반영하기는 하지만 Virtual DOM을 매번 생성하고 이전 결과물과 비교하는 것 자체가 비효율적이다. 비록 대부분의 경우 사소하지만 이러한 불필요한 동작이 디폴트 동작인 것이라면 나중에 앱이 커지고 성능 문제가 생겼을 때 어떤 부분이 병목 현상의 원인이 되는지 파악하기 어렵다.

반면에 Svelte의 경우 VirtualDom을 사용하지 않는다. Svelte는 컴파일러이기 때문에 빌드 타임 때 이미 어떤 부분이 변경될 수 있는지 알고 있다. 다음과 같은 코드를 생성해 주기 때문에 매번 Virtual DOM을 생성, 비교하는 과정이 없이 효율적이고 빠르게 화면을 업데이트한다.

```jsx
if (changed.name) {	
	text.data = name;
}
```

<aside>
💡 React는 Virtual DOM을 사용하기 때문에 빠르다”라는 잘못된 정보가 널리 퍼져있는데 이는 사실이 아니다.

매번 Virtual DOM을 생성, 비교하지 않는 Svelte가 훨씬 빠르다.

React core team에서 useMemo, useCallback, Memo 등의 여러 최적화 API를 제공한다는 것 자체가 React가 기본적으로 빠르지 않다는 증거이다.

</aside>

- 그러면 왜 Virtual DOM을 사용할까?
    
    기존에는 [많은 프레임워크들](https://bestofjs.org/projects?tags=vdom)이 선언적인, 상태 주도 UI 개발이라는 목표 달성을 위해 Virtual DOM을 수단으로 사용했다. 하지만 Virtual DOM 없이도 비슷한 프로그래밍 모델을 달성할 수 있는 것으로 드러났으며 이것이 Svelte가 등장한 이유이다.
    

### 최상위 엘리먼트

```jsx
// React

function HelloWorld(){
	return (<> 
		<h1>Hello</h1>
		<p>World</p>
	</>)
}
```

```jsx
// Svelte

// HelloWorld.svelte
<h1>Hello</h1>
<p>World</p>
```

| React | Svelte |
| --- | --- |
| 최상위 엘리먼트는 항상 하나여야함 | 최상위 엘리먼트의 개수에 제약이 없음 |
| 불필요한 들여 쓰기가 필요함 | 불필요한 들여쓰기 필요 없음 |
- React는 왜 반드시 하나여야 할까?
    
    React 컴포넌트가 반환하는 것은 사실 실제 DOM이 아니라 가상의 엘리먼트들로 이루어진 자바스크립트 객체에 불과하다.
    
    ```jsx
    // 다음과 같이 감싸고 싶은 element가 없을 경우 fragment 또는 축약형 사용한다.
    function HelloWorld(){
    	// JSX 문법으로 작성한 코드는 
    	// 결국에는 babel에 의해 자바스크립트 객체로 변환된다.
    	// 이 방법은 함수가 2개 이상을 반환할 수 없으니 불가능하다.
    	return (
    		<h1>Hello</h1> // React.createElement('h1', null, 'Hello')
    		<p>World</p> // React.createElement('p', null, 'World')
    	)
    }
    
    function HelloWorld(){
    
    	// React.createElement(React.Fragment, null, React.createElement('h1', null, 'Hello'), React.createElement('p', null, 'World')) 
    	return (<> 
    		<h1>Hello</h1>
    		<p>World</p>
    	</>)
    }
    ```
    
- Svelte는 왜 제약이 없을까?
    
    Svelte 컴포넌트에 실제(~~가상~~) 엘리먼트로 이루어진 HTML을 작성하기 때문에 React와 같은 제약이 필요 없게 된다.
    
    ```jsx
    <h1>Hello</h1>
    <p>World</p>
    ```
    

### State, Binding

```jsx
// React
import { useState } from 'react'

export default () => {
	const [a, setA] = useState(1);
	const [b, setB] = useState(2);
	
	function handleChangeA(event){
		setA(+event.target.value);
	}
	
	function handleChangeB(event){
		setB(+event.target.value);
	}
	
	return (
		<div>
			<input type="number" value={a} onChange={handleChangeA} />
			<input type="number" value={b} onChange={handleChangeB} />
			
			<p>
				{a} + {b} = {a + b}
			</p>
		</div>
	)
}
```

```jsx
// Svelte
<script>
	let a = 1;
	let b = 2;
</script>

<div>
	<input type="number" bind:value={a} />
	<input type="number" bind:value={b} />
	
	<p>
		{a} + {b} = {a + b}
	</p>
</div>
```

| React | Svelte |
| --- | --- |
| state를 사용하려면 useState를 명시적으로 작성 | 일반 자바스크립트 변수를 선언하면 컴파일러가 알아서 해줌 |
| input의 값이 변경되었을 때 state를 변경하는 코드를 명시적으로 작성 | bind 지시자를 통해 다음 코드와 기능적으로 동일하다 `value={state} on:input={(event) ⇒ state = +event.target.value}` |
| +를 통해 숫자로 변경을 해줘야함 | bind 지시자를 통해 이 문제도 해결됨 |

<aside>
💡 비슷한 점은 React도 useState를 최상단에서만 사용할 수 있듯이
Svelte도 최상단에서 let으로 선언한 변수만이 reactive 한 값이 된다. 함수 안에서 let을 사용하면 그냥 순수 자바스크립트 코드와 동일하다.

</aside>

## 헷갈리기 쉬운 부분

### 반응성 구문 실행 시점

반응성 구문은 동기적으로 실행되지 않는다.

```jsx
<script>
	let count = 0;

	function increment(){
		count += 1;
	}
</script>

<button on:click={increment}>
	clicks: {count}
</button>
```

1. click 하면 숫자가 증가하는 간단한 어플리케이션
2. Svelte에서 상태값 으로 부터 파생된 값이 필요할 경우 `$: statement`   (반응성 구문)를 통해 이를 해결한다.
($: 은 [Labled statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label)라는 JavaScript 문법이다. 하지만 svelte는 컴파일러를 이용해서 본래의 JS가 제공하는 기능이 아닌 다른 목적으로 사용하고 있기 때문에 많은 의견이 갈리는 부분이라고 한다.)
3. 하지만 주의해야할 점이 있다. state와는 달리 반응성 구문은 동기적으로 실행되지 않는다. (모든 함수 실행이 종료되고 DOM이 변경되기 전에 실행된다.)
4. tick을 사용하면 이러한 문제를 해결할 수 있다. (tick의 동작 원리는 추후 설명)

<aside>
💡 반응성 구문의 의존성을 숨겨버리면 컴파일러가 어떤 값에 의존하는지 모르기 때문에 실행되지 않는다.

</aside>

### DOM 변경 시점

DOM은 동기적으로 변경되지 않는다.

```jsx
<script>
	let framework = 'React';
</script>

<h1>I am using {framework} now.</h1>

<button on:click={() => framework = 'Svelte'}>
	use Svelte
</button>
```

1. 사용 중인 프레임워크를 표시하는 간단한 어플리케이션
2. 상태 값을 변경하고 즉시 DOM을 출력해 보면 변경되기 전 값이 출력됨
3. 그 이유는 DOM 또한 비동기적으로 변경이 되기 때문
4. 이 또한 tick을 사용하면 해결할 수 있음

### tick은 어떻게 동장할까?

상태 값이 변경될 때마다 DOM을 동기적으로 변경한다면 지연 시간이 길어지고 다음 라인의 코드가 늦게 실행될 것이다. 따라서 Svelte는 변경된 상태 값을 기억하고 있다가 DOM 변경을 한 번에 처리한다. (일괄처리 - batching)

tick함수를 호출하면 다음과 같은 프로미스가 반환된다.

```jsx
function tick(){
	return new Promise((resolve) => {
		// 변경된 state를 DOM에 반영하는 코드
		resolve();
	});
}

// 만약 변경된 상태값이 없다면 즉시 resolve된다.
function tick(){
	return Promise.resolve();
}
```

결과적으로 `await tick()`의 의미는 변경된 상태값을 DOM에 반영할 때까지 기다린다는 의미이다. 

아까 상태 값을 변경한 직후 DOM, 파생된 값을 읽었을 때 최신 값을 읽을 수 없었고 그것을 `tick` 을 이용해서 해결했었는데 이제 왜 해결되었는지 알 수 있다.

이벤트 핸들러에서 state를 변경하고 그로 인해 DOM이 변경되고, 반응성 구문이 실행될 때 순서는 다음과 같다.

1. 이벤트 핸들러 실행
2. state 변경(동기)
3. 이벤트 핸들러 종료
4. 반응성 구문 실행
5. 변경된 모든 state로 한 번에 DOM 변경

그래서 2번과 3번 사이에서 console.log를 출력하려고 했을 때 반응성 구문이 실행되기 이전 값, DOM이 변경되기 이전 값이 출력되었던 것이다.

그래서 `await tick()`으로 4, 5번이 실행될 때까지 기다린 후 출력하면 최신 값을 얻을 수 있었다.